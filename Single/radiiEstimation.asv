function cM = radiiEstimation(binaryVolume, cM, resolution)
% This function estimate radius at each node using rayburst algorithm
%
% inputs,
%   binaryVolume : 3D image volume of segmented vessels. 
%                  Use logical datatype.
%   cM           : Connectivity matrix of the medial points
%   resolution   : Resolution of the input image in micro meters. 
%                  Use 3-element array, e.g. [0.9,0.9,1.2]
%   
% outputs,
%   cM           : Updated connectivity matrix
% 
%
% Written by Vibujithan.V, University of Auckland (2019)

N = 100;
radiiOfRays = orthogonalPlanarRayburst(binaryVolume, cM, N, resolution);
radiiOfRays(isinf(radiiOfRays)) = NaN;
radii = mean(radiiOfRays,2,'omitnan');

cM(:,7) = radii;

end
%%  Helper function that casts rays out from the plane normal to the edge orientation
function radiiOfRays = orthogonalPlanarRayburst(binaryVolume,cM, N, resolution)

outside = ~binaryVolume;
blockSize = size(binaryVolume);

l = size(cM,1);

radiiOfRays = zeros(l,N);

v = [1, 0, 0]';
n = [0,0,1]';
V = zeros(3,N);
Rz = @(t) [cos(t), -sin(t), 0; sin(t), cos(t), 0; 0, 0, 1];

i=0;
for t = 0:2*pi/N:2*pi-(2*pi/N)
    i=i+1;
    vR = Rz(t)*v;
    V(:,i) =vR;
end

% Mid point of the edge
[aX,aY,aZ] = ind2sub(blockSize, cM(:,1));
[bX,bY,bZ] = ind2sub(blockSize, cM(:,2));

pX  = round((aX+bX)./2);
pY  = round((aY+bY)./2);
pZ  = round((aZ+bZ)./2);

normDirections = [cM(:,4),cM(:,5),cM(:,6)]';

parfor i=1:l    
    vD = normDirections(:,i);

    if(isequal(n,abs(vD)))
        VRotated = V;
    else
        VRotated = rotationMatrix(n,vD,0)*V;
    end
    
    VRotated = bsxfun(@rdivide,VRotated,sqrt(sum(VRotated.*VRotated))); % normalizing    
    radiiOfRays(i,:) = findEdgeRadius(outside,[pX(i);pY(i);pZ(i)],VRotated, resolution);
end
end

%% Helper function to find how far each ray travelled before encountering a boundary

function radii = findEdgeRadius(outerSpace,middlePoint,direction, resolution)

N = size(direction,2);
blockSize =size(outerSpace);
radii = Inf(1,N);
limit = 100;

parfor d=1: N
    travel=0;
    foundEdge =false;
    while(travel < limit && ~foundEdge)
        travel=travel+1;
        cordinate = floor(middlePoint + travel.* [direction(1,d);direction(2,d);direction(3,d)]);
        x=cordinate(1);
        y=cordinate(2);
        z=cordinate(3);
        
        foundEdge = x <= 0 || y <= 0 || z <= 0 || x > blockSize(1) || y > blockSize(2) || z > blockSize(3)|| outerSpace(x,y,z);
        
        if(foundEdge)
              radii(d) = sqrt(sum((resolution' .* ((middlePoint - cordinate))).^2)); 
        end
    end     
end
end